<!doctype html>
<html>
    <head>
        <title>Your first game with toy</title>
        <meta charset="utf-8">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<link rel="stylesheet" href="assets/css/alt.css" />
		<link rel="stylesheet" href="assets/css/prism.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
        <style>
            .left-half,
            .right-half {
                position: absolute;
                top: 0px;
                height: 100%;
            }

            .left-half {
                left: 0px;
                width: 33%;
            }
            
            .right-half {
                right: 0px;
                width: 67%;
            }
            
            .emscripten { padding-right: 0; margin-left: auto; margin-right: auto; display: block; }
            .app {
                position: relative;
                top: 0px;
                left: 0px;
                width: 100%;
                height: 100%;
                overflow: hidden;
            }
            div.emscripten { text-align: center; }
            canvas.emscripten { background-color: black; }
            .spinner {
                height: 50px;
                width: 50px;
                margin: 0px auto;
                animation: rotation 0.8s linear infinite;
                border-left: 10px solid rgb(0,150,240);
                border-right: 10px solid rgb(0,150,240);
                border-bottom: 10px solid rgb(0,150,240);
                border-top: 10px solid rgb(100,0,200);
                border-radius: 100%;
                background-color: rgb(200,100,250);
            }
            @keyframes rotation {
                from {transform: rotate(0deg);}
                to {transform: rotate(360deg);}
            }
        </style>
    </head>
    <body>
    <div>
        <div class="left-half">
            <div class="main" style="height: 100%;">
            
                <nav id="nav" style="height: 3.5em; padding: 0.25em">
                    <ul>
                        <li><a href="https://toyengine.io"><img src="logo/toyengine.png" alt="" style="display: inline; height: 52px; margin-top: 5px; text-align: left;"/></a/</li>
                        <li><a href="https://www.patreon.com/toyengine"><img class="ui image" src="images/patreon.png"></a></li>
                    </ul>
                </nav>

                <section id="snippets" class="main special" style="height: calc(100% - 7em); overflow: auto; padding: 1em;">
                    <div class="container" style="height: 100%;">
                        <header class="major">
                            <h2>Live tutorial</h2>
                        </header>

<div id="section_0" class="row gtr-100 gtr-uniform" style="hidden: true;">       
<div class="doc col-12">
    <h3>Wren language support</h3>
    <p>Here is the culmination of the last week of work, which I've spent on adding <strong>another language</strong> to program toy. Unlike the previous language, lua, <strong>Wren is class-based</strong>, while sharing many of the advantages that make lua such a great scripting language for games.</p>
    <p>This tutorial will teach you the fundamentals of setting up a <strong>simple yet fully working game</strong> using toy. Thanks to how portable toy is, you will do all this right here, on this web page :)</p>
    <h3>Creating the App</h3>
    <p>The code on the right is your starting point: it setups the minimal toy game, a running app, with a black screen :)
    The <code>GameModule</code> interface provides five main hooks for writing your game logic:</p>
    <ul>
    <li><code>init()</code> is called when initializing the game</li>
    <li><code>start()</code> is called when the game session is started</li>
    <li><code>pump()</code> is called on each frame</li>
    <li><code>scene()</code> is called everytime a scene is created</li>
    <li><code>paint()</code> is called each frame when a scene is painted</li>
    </ul>
</div>
</div>

<div id="section_1" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Creating a viewer</h3>
    <p>The first thing we will do is creating a <code>Viewer</code> in the UI hierarchy of our app. To do this, add the following in the body of the <code>pump()</code> function.</p>
<pre><code class="block language-wren">var viewer = Ui.scene_viewer(ui)
</code><button class="overlay paste">paste</span></pre>
    <p>Note: In Wren, everything is an object, and every function is a method, so this is actually a static method on the <code>Ui</code> class. In C++, it's a regular function.</p>
</div>
<div class="doc col-12">
    <h3>Reload the game</h3>
    <p>Press <code>reload</code>. You will get an error: the symbol <code>Ui</code> is not yet defined. It is found in the <code>mud</code> module, which you have to add to the imports of your script:</p>
<pre><code class="block language-wren">import "mud" for Ui
</code><button class="overlay paste">paste</button></pre>
    <p>Reload again: nothing changed! You created an empty black viewport. Just to be sure there is a viewer, try this:</p>
<pre><code class="block language-wren">viewer.viewport.clear_colour = Colour.Red
</code><button class="overlay paste">paste</button></pre>
</div>
</div>

<div id="section_2" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Drawing a cube</h3>
    <p>Next, we want to draw some geometry to the viewport. First, we need to initialize the scene graph using <code>Scene::begin()</code>.</p>
<pre><code class="block language-wren">var graph = viewer.scene.begin()
</code><button class="overlay paste">paste</button></pre>
    <p>Once the graph is initialized, we can start actually drawing geometry. Add these to the <code>paint()</code> function:</p>
    <ul>
    <li>declare a node in the graph, which holds the transform, by calling <code>gfx::node()</code>, passing the parent, an object (null), and a position</li>
    <li>declare a shape as a child of this node, by calling<code>gfx::shape()</code> passing the parent, the shape, and a symbol holding the shape colours</li>
    </ul>
<pre><code class="block language-wren">var node = Gfx.node(graph)
Gfx.shape(node, Cube.new(), Symbol.new(Colour.White))
</code><button class="overlay paste">paste</button></pre>
    <p>Press <code>reload</code>. Another error ? We need to add the missing symbol names we just used to the <code>mud</code> import line.</p>
<pre><code class="block language-wren">import "mud" for Colour, Cube, Symbol, Ui, Gfx
</code><button class="overlay paste">paste</button></pre>
</div>
</div>

<div id="section_3" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Controlling the camera</h3>
    <p>The simplest way is to call <code>ui::orbit_controller</code>, which takes a <code>Viewer</code> and controls its camera. It's the simplest controller: it handles input to make the camera orbit around a fixed center point, when pressing <code>Middle Mouse Button</code>.</p>
<pre><code class="block language-wren">var orbit = Ui.orbit_controller(viewer)
</code><button class="overlay paste">paste</button></pre>
</div>
<div class="doc col-12">
    <h3>Drawing more cubes</h3>
    <p>Let's create more cubes, in a loop, by passing different colors and positions to the<code>node()</code> and <code>draw()</code> functions.</p>
<pre><code class="block language-wren">for (i in 0...50) {
    var colour = Colour.hsl(i / 50, 1, 0.5)
    var node = Gfx.node(graph, null, Vec3.new(i, i, i))
    Gfx.draw(node, Cube.new(Vec3.new(1)), Symbol.new(colour))
}
</code><button class="overlay paste">paste</button></pre>
    <p>Note: the <code>Symbol</code> object controls how the shape is rendered. Its two first parameters are the solid/plain colour, and the wireframe colour (if any).</p>
</div>
</div>

<div id="section_4" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Make it random</h3>
    <p>Wren provides a built-in <code>Random</code> number generator, on which you call the <code>float()</code> or <code>int()</code> functions to generate numbers in the given range. First, create it.</p>
<pre><code class="block language-wren">var rand = Random.new()</code>
<button class="overlay paste">paste</button></pre>
    <p>Then, inside the loop, let's create random attributes and feed these to the <code>node()</code> and <code>draw()</code> functions.</p>
<pre><code class="block language-wren">var position = Vec3.new(rand.float(-50, 50), rand.float(0, 20), rand.float(-50, 50))
var extents = Vec3.new(rand.float(1, 5))
var colour = Colour.hsl(rand.float(0, 1), 1, 0.5)
</code><button class="overlay paste">paste</button></pre>
    <p>You will also need to import the <code>Random</code> object. It lies in a built-in Wren module called <code>random</code></p>
<pre><code class="block language-wren">import "random" for Random</code>
<button class="overlay paste">paste</button></pre>
</div>
</div>

<div id="section_5" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>First part recap</h3>
    <p>By now, you should have a code similar to the following:</p>
<pre style="overflow: auto; max-height: 40em;"><code class="block language-wren">import "random" for Random
import "mud" for Vec3, Colour, Cube, Symbol, Ui, Gfx

foreign class MyGame {
    static new(module) { __constructor.call(MyGame, module) }
    static bind() { __constructor = VirtualConstructor.ref("GameModuleBind") }
    
    init(app, game) { start(app, game) }
    
    start(app, game) {}
    
    pump(app, game, ui) {
        var viewer = Ui.scene_viewer(ui)
        var orbit = Ui.orbit_controller(viewer)
        var graph = viewer.scene.begin()
        
        var rand = Random.new()
        for (i in 0...50) {
            var position = Vec3.new(rand.float(-50, 50), rand.float(0, 20), rand.float(-50, 50))
            var extents = Vec3.new(rand.float(1, 5))
            var colour = Colour.hsl(rand.float(0, 1), 1, 0.5)
                
            var node = Gfx.node(graph, null, position)
            Gfx.draw(node, Cube.new(extents), Symbol.new(colour))
        }
    }
    
    scene(app, scene) {}
    
    paint(app, scene, graph) {}
}

MyGame.bind()

var game = MyGame.new(module)
</code><button class="overlay paste">paste</button></pre>
</div>
</div>

<div id="section_6" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Defining an Entity</h3>
    <p>Until now, we were directly declaring pure graphical shapes. To design a game, it's convenient to define some <code>Entity</code> types.</p>
<pre><code class="block language-wren">class Body {
    construct new(id, parent, position) {
        _complex = Complex.new(id, __cls.type)
        _entity = Entity.new(id, _complex, parent, position)
        _movable = Movable.new(_entity)
        _complex.setup([_entity, _movable])
    }
    
    entity { _entity }
    
    static bind() { __cls = ScriptClass.new("Body", [Entity.type, Movable.type]) }
}
</code><button class="overlay paste">paste</button></pre>
    <p>Let's add the above definition to the top of our script: we define an Entity with two components: an <code>Entity</code>, and a <code>Movable</code>. This is enough to formalize spatial objects that can also move.</p>
    <p>We also need to bind this new class, somewhere near the end:</p>
<pre><code class="block language-wren">Body.bind()</code>
<button class="overlay paste">paste</button></pre>
</div>
</div>

<div id="section_7" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Creating a World, a Scene, and Entities</h3>
    <p>Instead of directly declaring pure graphical shapes, we will now render proper Entities. To do this, we need: a <code>World</code> to contain the entities, a <code>Scene</code> to render them, and a list of entities:</p>
<pre><code class="block language-wren">var GWorld = null
var GScene = null
var GBodies = []
</code><button class="overlay paste">paste</button></pre>
    <p>We will create all these inside the <code>start()</code> function. First, let's create the game world:</p>
<pre><code class="block language-wren">GWorld = DefaultWorld.new("Example")
game.world = GWorld.world
</code><button class="overlay paste">paste</button></pre>
    <p>Then, let's create our game Entities using the newly defined <code>Body</code> class, as children of the <code>World</code> origin.</p>
<pre><code class="block language-wren">GBodies.add(Body.new(0, GWorld.world.origin, Vec3.new(0)))</code><button class="overlay paste">paste</button></pre>
    <p>Finally we need to add a scene to the game, which we will render in our viewport.</p>
<pre><code class="block language-wren">GScene = app.add_scene()
</code><button class="overlay paste">paste</button></pre>
</div>
</div>

<div id="section_8" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Import the symbols</h3>
    <p>Let's not forget to import the newly used symbols:</p>
<pre><code class="block language-wren">import "mud" for ScriptClass, Complex // ...
import "toy" for DefaultWorld, Entity, Movable
</code><button class="overlay paste">paste</button></pre>
    <h3>Check that it compiles</h3>
    <p>Let's hit <code>reload</code>: it should compile, but the result should be the same as before! We are still rendering arbitrary shapes in the <code>pump()</code> handler, but we want to render our newly created <code>Entities</code>!</p>
</div>
</div>


<div id="section_9" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Rendering the Scene</h3>
    <p>Because the scene is now managed by the application, instead of creating a <code>scene_viewer()</code>, which contains its own <code>Scene</code>, we create a simple <code>viewer()</code> and pass it the scene to render. Let's replace the code inside <code>pump()</code> with this:</p>
<pre><code class="block language-wren">var viewer = Ui.viewer(ui, GScene.scene)
var orbit = Ui.orbit_controller(viewer, 0, -0.37, 100.0)
</code><button class="overlay paste">paste</button></pre>
    <p>The rendering of this scene will now be handled by the application: it will call the <code>paint()</code> handler. We need to move the actual rendering code inside <code>paint()</code>:</p>
<pre><code class="block language-wren">for(body in GBodies) {
    var node = Gfx.node(graph, body, body.entity.position, body.entity.rotation)
    Gfx.shape(node, Cube.new(), Symbol.new(Colour.White))
}
</code><button class="overlay paste">paste</button></pre>
    <p>We can also add a radiance environment and a sun light at the beginning of our <code>paint()</code> handler:</p>
<pre><code class="block language-wren">Gfx.radiance(graph, "radiance/tiber_1_1k.hdr", BackgroundMode.Radiance)
Gfx.sun_light(graph, 0, 0.37)
</code><button class="overlay paste">paste</button></pre>
</div>
</div>

<div id="section_10" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Adding fields to the Entity</h3>
    <p>How to store shapes and colours on each of our <code>Bodies</code>? Let's add two fields to our <code>Body</code> Entity, to store both its shape and the colour: this needs to be added to our class:</p>
<pre><code class="block language-wren">class Body {
    construct new(id, parent, position, shape, colour) {
        // ...
        _shape = shape
        _colour = colour
    }

    // ...
    shape { _shape }
    colour { _colour }
    // ...
}
</code><button class="overlay paste">paste</button></pre>
    <p>Now we can modify our rendering code to render each <code>Body</code> using the <code>Shape</code> and <code>Colour</code> stored in its fields:</p>
<pre><code class="block language-wren">for(body in GBodies) {
    var self = Gfx.node(graph, body, body.entity.position, body.entity.rotation)
    Gfx.shape(self, body.shape, Symbol.new(body.colour))
}
</code><button class="overlay paste">paste</button></pre>
</div>
</div>

<div id="section_11" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Put the randomness back in</h3>
    <p>The last step is to update the creation code inside <code>start()</code>. We can now create an array of <code>Bodies</code> and use the random logic from the first part of the tutorial, to fill in each <code>Body</code> attributes: position, shape and colour:</p>
<pre><code class="block language-wren">var rand = Random.new()
for (i in 0...50) {
    var position = Vec3.new(rand.float(-50, 50), rand.float(0, 20), rand.float(-50, 50))
    var colour = Colour.hsl(rand.float(0, 1), 1, 0.5)
    var shape = Cube.new(Vec3.new(rand.float(1, 5)))
    
    GBodies.add(Body.new(0, GWorld.world.origin, position, shape, colour))
}</code><button class="overlay paste">paste</button></pre>
    <p>You can also create <code>Spheres</code> instead of <code>Cubes</code>:</p>
<pre><code class="block language-wren">var shape = Sphere.new(rand.float(1, 5))
</code><button class="overlay paste">paste</button></pre>
</div>
</div>

<div id="section_12" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Result</h3>
    <p>Finally, pressing <code>reload</code> should yield the expected scene filled with your randomly created entities of various size, shapes and colours. If you didn't manage, don't worry: the full solution is on the next page.</p>
    <p>This looks very similar to what we did in the first part, right ? Why go to all this trouble for the same result ? In the first part, we only had pure immediately rendered graphical shapes. Having proper game Entities instead, means we can apply all sorts of game logic to these objects, like add physics to them. The next part will show you how to do that.</p>
</div>
</div>

<div id="section_13" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Second part recap</h3>
    <p>By now, you should have a code similar to the following:</p>
<pre style="overflow: auto; max-height: 40em;"><code class="block language-wren">import "random" for Random
import "mud" for ScriptClass, Vec3, Complex, Colour, Cube, Symbol, Ui, Gfx, BackgroundMode
import "toy" for DefaultWorld, Entity, Movable

class Body {
    construct new(id, parent, position, shape, colour) {
        _complex = Complex.new(id, __cls.type)
        _entity = Entity.new(id, _complex, parent, position)
        _movable = Movable.new(_entity)
        _shape = shape
        _colour = colour
        _complex.setup([_entity, _movable])
    }
    
    entity { _entity }
    shape { _shape }
    colour { _colour }
    
    static bind() { __cls = ScriptClass.new("Body", [Entity.type, Movable.type]) }
}

var GWorld = null
var GScene = null
var GBodies = []

foreign class MyGame {
    static new(module) { __constructor.call(MyGame, module) }
    static bind() { __constructor = VirtualConstructor.ref("GameModuleBind") }
    
    init(app, game) { start(app, game) }
    
    start(app, game) {
        GWorld = DefaultWorld.new("Example")
        game.world = GWorld.world
        
        var rand = Random.new()
        for (i in 0...50) {
            var position = Vec3.new(rand.float(-50, 50), rand.float(0, 20), rand.float(-50, 50))
            var colour = Colour.hsl(rand.float(0, 1), 1, 0.5)
            var size = Vec3.new(rand.float(1, 5))
            
            GBodies.add(Body.new(0, GWorld.world.origin, position, Cube.new(size), colour))
        }
        
        GScene = app.add_scene()
    }
    
    pump(app, game, ui) {
        var viewer = Ui.viewer(ui, GScene.scene)
        var orbit = Ui.orbit_controller(viewer, 0, -0.37, 100.0)
    }
    
    scene(app, scene) {}
    
    paint(app, scene, graph) {
        Gfx.radiance(graph, "radiance/tiber_1_1k.hdr", BackgroundMode.Radiance)
        Gfx.sun_light(graph, 0, 0.37)
        
        for(body in GBodies) {
            var node = Gfx.node(graph, body, body.entity.position, body.entity.rotation)
            Gfx.shape(node, body.shape, Symbol.new(body.colour))
        }
    }
}

Body.bind()
MyGame.bind()

var game = MyGame.new(module)
</code><button class="overlay paste">paste</button></pre>
</div>
</div>

<div id="section_14" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Adding physics</h3>
    <p>Let's add one more component to our <code>Body</code> class. The <code>Solid</code> component adds rigid body physics to an <code>Entity</code>. It expects a <code>CollisionShape</code>, which we construct from a <code>Shape</code>, a flag to specify whether it's <code>static</code>, and its <code>mass</code>.</p>
<pre><code class="block language-wren">class Body {
    construct new(id, parent, position, shape, colour) {
        // add this line
        _solid = Solid.new(_entity, CollisionShape.new(shape), false, 1.0)
        // ...
        // modify this line: we need to add that new component to the Entity
        _complex.setup([_entity, _movable, _solid])
    }
    
    // modify this line: we need to register that component in our Entity class
    static bind() { __cls = ScriptClass.new("Body", [Entity.type, Movable.type, Solid.type]) }
}
</code><button class="overlay paste">paste</button></pre>
    <p>Press <code>reload</code>. Fix the missing import error (<code>Solid</code> is in the toy module). Press <code>reload</code> again. Your bodies will now fall downwards!</p>
</div>
</div>

<div id="section_15" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Defining a Terrain class</h3>
    <p>We don't want our objects to fall indefinitely. Let's add a new <code>Terrain</code> Entity class.</p>
<pre><code class="block language-wren">class Terrain {
    construct new(id, parent, size) {
        _quad = Quad.new(Vec3.new(size,0,size), Vec3.new(size,0,-size), Vec3.new(-size,0,-size), Vec3.new(-size,0,size))
        _complex = Complex.new(id, __cls.type)
        _entity = Entity.new(id, _complex, parent, Vec3.new(0, -10, 0))
        _solid = Solid.new(_entity, CollisionShape.new(_quad), true, 0.0)
        _complex.setup([_entity, _solid])
    }
    
    quad { _quad }
    entity { _entity }
    
    static bind() { __cls = ScriptClass.new("Terrain", [Entity.type, Solid.type]) }
}
</code><button class="overlay paste">paste</button></pre>
    <p>Two main differences with our <code>Body</code> class:</p>
    <ul>
    <li>we create a <code>Quad</code> shape, using the <code>size</code> given as a parameter to our constructor</li>
    <li>we pass <code>true</code> to the <code>static</code> parameter of the <code>Solid</code>, and a <code>mass</code> of <code>0.0</code></li>
    <li>we don't need a <code>Movable</code> component this time</li>
    </ul>
</div>
</div>

<div id="section_16" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Bind the Terrain class</h3>
<pre><code class="block language-wren">Terrain.bind()</code><button class="overlay paste">paste</button></pre>
    <h3>Creating the Terrain object</h3>
    <p>Let's declare a <code>GTerrain</code> global variable next to our other globals, to hold the terrain object.</p>
<pre><code class="block language-wren">var GTerrain = null</code><button class="overlay paste">paste</button></pre>
    <p>Let's create the terrain object, with a <code>size</code> of <code>100</code>, in the body of <code>start()</code> handler:</p>
<pre><code class="block language-wren">GTerrain = Terrain.new(0, GWorld.world.origin, 100)</code><button class="overlay paste">paste</button></pre>
</div>
<div class="doc col-12">
    <h3>Rendering the Terrain object</h3>
    <p>Finally, we need to add some rendering logic: again, like for the <code>Bodies</code>, we simply render its shape, with a predefined grey colour:</p>
<pre><code class="block language-wren">var terrain = Gfx.node(graph, GTerrain, GTerrain.entity.position, GTerrain.entity.rotation)
Gfx.shape(terrain, GTerrain.quad, Symbol.new(Colour.new(0.3, 1)))</code><button class="overlay paste">paste</button></pre>
</div>
</div>

<div id="section_17" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Third part recap</h3>
    <p>By now, you should have a code similar to the following:</p>
<pre style="overflow: auto; max-height: 40em;"><code class="block language-wren">import "random" for Random
import "mud" for ScriptClass, Vec3, Complex, Colour, Cube, Sphere, Quad, Symbol, Ui, Gfx, BackgroundMode
import "toy" for DefaultWorld, Entity, Movable, Solid, CollisionShape

class Body {
    construct new(id, parent, position, shape, colour) {
        _complex = Complex.new(id, __cls.type)
        _entity = Entity.new(id, _complex, parent, position)
        _movable = Movable.new(_entity)
        _solid = Solid.new(_entity, CollisionShape.new(shape), false, 1.0)
        _shape = shape
        _colour = colour
        _complex.setup([_entity, _movable, _solid])
    }
    
    entity { _entity }
    shape { _shape }
    colour { _colour }
    
    static bind() { __cls = ScriptClass.new("Body", [Entity.type, Movable.type, Solid.type]) }
}

class Terrain {
    construct new(id, parent, size) {
        _quad = Quad.new(Vec3.new(size,0,size), Vec3.new(size,0,-size), Vec3.new(-size,0,-size), Vec3.new(-size,0,size))
        _complex = Complex.new(id, __cls.type)
        _entity = Entity.new(id, _complex, parent, Vec3.new(0, -10, 0))
        _solid = Solid.new(_entity, CollisionShape.new(_quad), true, 0.0)
        _complex.setup([_entity, _solid])
    }
    
    quad { _quad }
    entity { _entity }
    
    static bind() { __cls = ScriptClass.new("Terrain", [Entity.type, Solid.type]) }
}

var GWorld = null
var GScene = null
var GTerrain = null
var GBodies = []

foreign class MyGame {
    static new(module) { __constructor.call(MyGame, module) }
    static bind() { __constructor = VirtualConstructor.ref("GameModuleBind") }
    
    init(app, game) { start(app, game) }
    
    start(app, game) {
        GWorld = DefaultWorld.new("World")
        game.world = GWorld.world
        
        GTerrain = Terrain.new(0, GWorld.world.origin, 100)
        
        var rand = Random.new()
        for (i in 0...50) {
            var position = Vec3.new(rand.float(-50, 50), rand.float(0, 20), rand.float(-50, 50))
            var colour = Colour.hsl(rand.float(0, 1), 1, 0.5)
            var size = Vec3.new(rand.float(1, 5))
            GBodies.add(Body.new(0, GWorld.world.origin, position, Cube.new(size), colour))
        }
        
        GScene = app.add_scene()
    }
    
    pump(app, game, ui) {
        var viewer = Ui.viewer(ui, GScene.scene)
        var orbit = Ui.orbit_controller(viewer, 0, -0.37, 100.0)
    }
    
    scene(app, scene) {}
    
    paint(app, scene, graph) {
        Gfx.radiance(graph, "radiance/tiber_1_1k.hdr", BackgroundMode.Radiance)
        Gfx.sun_light(graph, 0, 0.37)
        
        var terrain = Gfx.node(graph, GTerrain, GTerrain.entity.position, GTerrain.entity.rotation)
        Gfx.shape(terrain, GTerrain.quad, Symbol.new(Colour.new(0.3, 1)))
        
        for(body in GBodies) {
            var node = Gfx.node(graph, body, body.entity.position, body.entity.rotation)
            Gfx.shape(node, body.shape, Symbol.new(body.colour))
        }
    }
}

Body.bind()
Terrain.bind()
MyGame.bind()

var game = MyGame.new(module)
</code><button class="overlay paste">paste</button></pre>
</div>
</div>

<div id="section_18" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Defining an Agent class</h3>
    <p>To allow the user to control an object, let's add one more class: an <code>Agent</code>, which is a special kind of <code>Body</code>, with additional logic so that its movement can be controlled.</p>
<pre><code class="block language-wren">class Agent is Body {
    construct new(id, parent, position, shape, colour) {
        super(id, parent, position, shape, colour)
        _aiming = true
        _angles = Vec2.new(0)
        _force = Vec3.new(0)
        _torque = Vec3.new(0)
    }
    
    aiming { _aiming }
    angles { _angles }
    force { _force }
    torque { _torque }
}
</code><button class="overlay paste">paste</button></pre>
    <p>The <code>force</code> and <code>torque</code> will represent the translation and rotation forces applied to our agent, relative to itself. The <code>aiming</code> and <code>angles</code> fields will be used by the camera controller, to determine in which direction we are looking.</p>
</div>
</div>

<div id="section_19" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Adding the movement logic</h3>
    <p>Each frame, we will use the previously defined fields to modify the velocity of the actual simulated physics object. Let's add an <code>update()</code> function that we will call each frame to do the following:</p>
    <ul>
    <li>calculate the <code>force</code> in absolute coordinates</li>
    <li>apply the absolute <code>force</code>, together with the <code>torque</code>, to the physical <code>Solid</code> object</li>
    <li>set the <code>angular factor</code> to <code>0</code> to maintain our object upright in all situations</li>
    </ul>
<pre><code class="block language-wren">class Agent is Body {
    // ...
    update() {
        var velocity = this.solid.impl.linear_velocity()
        var force = Mud.rotate(this.entity.rotation, _force)
        this.solid.impl.set_linear_velocity(Vec3.new(force.x, velocity.y - 1, force.z))
        this.solid.impl.set_angular_velocity(_torque)
        this.solid.impl.set_angular_factor(Vec3.new(0))
    }
}
</code><button class="overlay paste">paste</button></pre>
    <p>Note: We are combining the force with the vertical component of the velocity, minus one, to simulate gravity.</p>
</div>
</div>

<div id="section_20" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Create the player Agent</h3>
    <p>Create another global variable <code>GAgent</code> near the other ones to hold our player agent. Then add this code to create it, in the body of the <code>start()</code> handler.</p>
<pre><code class="block language-wren">GAgent = Agent.new(0, GWorld.world.origin, Vec3.new(0), Cube.new(), Colour.White)
</code><button class="overlay paste">paste</button></pre>
    <h3>Rendering the Agent</h3>
    <p>To render our <code>Agent</code> separately from the other <code>Bodies</code>, let's factor out the code to render a body in a function <code>paint_body()</code> in our game class:</p>
<pre><code class="block language-wren">paint_body(app, graph, body) {
    var node = Gfx.node(graph, body, body.entity.position, body.entity.rotation)
    Gfx.shape(node, body.shape, Symbol.new(body.colour))
}
</code><button class="overlay paste">paste</button></pre>
    <p>Then let's call it from inside the <code>paint()</code> handler.</p>
<pre><code class="block language-wren">paint_body(app, graph, GAgent)
for(body in GBodies) {
    paint_body(app, graph, body)
}
</code><button class="overlay paste">paste</button></pre>
</div>
</div>


<div id="section_21" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Handling the input/control logic</h3>
    <p>To correctly handle input to control our object, we have to add three things inside the <code>pump()</code> handler right after creating the viewer:</p>
    <ul>
    <li>take keyboard control of the viewer if the game is playing and we don't have modal control yet</li>
    <li>call <code>hybrid_controller</code> with <code>ThirdPerson</code> mode: it handles the mouse <code>Agent</code> aiming angle for us</li>
    <li>call <code>velocity_controller</code>, to map the arrow keys to update the <code>force</code> and <code>torque</code> accordingly</li>
    </ul>
<pre><code class="block language-wren">if(game.mode == GameMode.Play && !viewer.modal()) {
    viewer.take_modal(62)
}

Ui.hybrid_controller(viewer, OrbitMode.ThirdPerson, GAgent.entity, GAgent.aiming, GAgent.angles)
Ui.velocity_controller(viewer, GAgent.force, GAgent.torque, 20)
</code><button class="overlay paste">paste</button></pre>
    <p>Finally we need to call the <code>update()</code> function we implemented on our <code>Agent</code> class, to apply the forces to the physical object.</p>
<pre><code class="block language-wren">GAgent.update()</code><button class="overlay paste">paste</button></pre>
</div>
</div>

<div id="section_22" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Fourth part recap</h3>
    <p>By now, you should have a code similar to the following:</p>
<pre style="overflow: auto; max-height: 40em;"><code class="block language-wren">import "random" for Random
import "mud" for ScriptClass, Vec2, Vec3, Complex, Colour, Cube, Sphere, Quad, Symbol, Ui, Gfx, BackgroundMode
import "toy" for DefaultWorld, Entity, Movable, Solid, CollisionShape, GameMode
import "ui" for OrbitMode

class Body {
    construct new(id, parent, position, shape, colour) {
        _complex = Complex.new(id, __cls.type)
        _entity = Entity.new(id, _complex, parent, position)
        _movable = Movable.new(_entity)
        _solid = Solid.new(_entity, CollisionShape.new(shape), false, 1.0)
        _shape = shape
        _colour = colour
        _complex.setup([_entity, _movable, _solid])
    }
    
    entity { _entity }
    solid { _solid }
    shape { _shape }
    colour { _colour }
    
    static bind() { __cls = ScriptClass.new("Body", [Entity.type, Movable.type, Solid.type]) }
}

class Agent is Body {
    construct new(id, parent, position, shape, colour) {
        super(id, parent, position, shape, colour)
        _aiming = true
        _angles = Vec2.new(0)
        _force = Vec3.new(0)
        _torque = Vec3.new(0)
    }
    
    update() {
        var velocity = this.solid.impl.linear_velocity()
        var force = Mud.rotate(this.entity.rotation, _force)
        this.solid.impl.set_linear_velocity(Vec3.new(force.x, velocity.y - 1, force.z))
        this.solid.impl.set_angular_velocity(_torque)
        this.solid.impl.set_angular_factor(Vec3.new(0))
    }
    
    aiming { _aiming }
    angles { _angles }
    force { _force }
    torque { _torque }
}

class Terrain {
    construct new(id, parent, size) {
        _quad = Quad.new(Vec3.new(size,0,size), Vec3.new(size,0,-size), Vec3.new(-size,0,-size), Vec3.new(-size,0,size))
        _complex = Complex.new(id, __cls.type)
        _entity = Entity.new(id, _complex, parent, Vec3.new(0, -10, 0))
        _solid = Solid.new(_entity, CollisionShape.new(_quad), true, 0.0)
        _complex.setup([_entity, _solid])
    }
    
    quad { _quad }
    entity { _entity }
    
    static bind() { __cls = ScriptClass.new("Terrain", [Entity.type, Solid.type]) }
}

var GWorld = null
var GScene = null
var GTerrain = null
var GBodies = []
var GAgent = null

foreign class MyGame {
    static new(module) { __constructor.call(MyGame, module) }
    static bind() { __constructor = VirtualConstructor.ref("GameModuleBind") }
    
    init(app, game) { start(app, game) }
    
    start(app, game) {
        GWorld = DefaultWorld.new("World")
        game.world = GWorld.world
        
        GTerrain = Terrain.new(0, GWorld.world.origin, 100)
        GAgent = Agent.new(0, GWorld.world.origin, Vec3.new(0), Cube.new(), Colour.White)
        
        var rand = Random.new()
        for (i in 0...50) {
            var position = Vec3.new(rand.float(-50, 50), rand.float(0, 20), rand.float(-50, 50))
            var colour = Colour.hsl(rand.float(0, 1), 1, 0.5)
            var size = Vec3.new(rand.float(1, 5))
            GBodies.add(Body.new(0, GWorld.world.origin, position, Cube.new(size), colour))
        }
        
        GScene = app.add_scene()
    }
    
    pump(app, game, ui) {
        var viewer = Ui.viewer(ui, GScene.scene)

        if(game.mode == GameMode.Play && !viewer.modal()) {
            viewer.take_modal(62)
        }
        
        Ui.hybrid_controller(viewer, OrbitMode.ThirdPerson, GAgent.entity, GAgent.aiming, GAgent.angles)
        Ui.velocity_controller(viewer, GAgent.force, GAgent.torque, 20)

        GAgent.update()
    }
    
    scene(app, scene) {}
    
    paint(app, scene, graph) {
        Gfx.radiance(graph, "radiance/tiber_1_1k.hdr", BackgroundMode.Radiance)
        Gfx.sun_light(graph, 0, 0.37)
        
        var terrain = Gfx.node(graph, GTerrain, GTerrain.entity.position, GTerrain.entity.rotation)
        var material = Gfx.pbr_material(app.gfx, "ground", Colour.new(0.3, 1))
        Gfx.shape(terrain, GTerrain.quad, Symbol.new(Colour.White), 0, material)
        
        paint_body(app, graph, GAgent)
        
        for(body in GBodies) {
            paint_body(app, graph, body)
        }
    }
    
    paint_body(app, graph, body) {
        var node = Gfx.node(graph, body, body.entity.position, body.entity.rotation)
        var material = Gfx.pbr_material(app.gfx, "body %(body.entity.id)", body.colour)
        Gfx.shape(node, body.shape, Symbol.new(Colour.White), 0, material)
    }
}

Body.bind()
Terrain.bind()
MyGame.bind()

var game = MyGame.new(module)
</code><button class="overlay paste">paste</button></pre>
</div>
</div>

                    </div>
                </section>
                
                <ul style="height: 3.5em; padding: 0.5em 5em 0.5em 5em; background-color: rgba(60, 60, 60, 1);">
                    <li style="display: inline-block;"><a id="prev" class="button">Previous</a></li>
                    <li style="display: inline-block;"><a id="next" class="button">Next</a></li>
                </ul>
            </div>
        </div>
        <div class="right-half">
            <canvas class="emscripten app" id="canvas" oncontextmenu="event.preventDefault()"></canvas>
            <figure style="overflow:visible;" id="spinner"><div class="spinner"></div></figure>
            <div class="emscripten">
                <progress value="0" max="100" id="progress" hidden=1></progress>    
            </div>
        </div>
        <script type='text/javascript'>
            var progressElement = document.getElementById('progress');
            var spinnerElement = document.getElementById('spinner');
            var Module = {
                preRun: [function() {
                
                    var paste = Module.cwrap('paste', null, ['string']);
                    
                    function handlePaste (e) {
                        e.stopPropagation();
                        e.preventDefault();

                        var clipboardData = e.clipboardData || window.clipboardData;
                        var text = clipboardData.getData('Text');

                        paste(text);
                    }

                    document.addEventListener('paste', handlePaste);
                    
                    var paste_buttons = document.getElementsByClassName("paste");
                    for (i = 0; i < paste_buttons.length; i++) {
                        paste_buttons[i].addEventListener('click', function() {
                            var text = this.previousSibling.innerText
                            Module.ccall('paste', null, ['string'], [text]);
                        });
                    }
                }],
                postRun: [],
                print: (function() {
                    return function(text) {
                        if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ');
                        console.log(text);
                    };
                })(),
                printErr: function(text) {
                    if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ');
                    if (0) { // XXX disabled for safety typeof dump == 'function') {
                        dump(text + '\n'); // fast, straight to the real console
                    } else {
                        console.error(text);
                    }
                },
                canvas: (function() {
                    var canvas = document.getElementById('canvas');
                    // As a default initial behavior, pop up an alert when webgl context is lost. To make your
                    // application robust, you may want to override this behavior before shipping!
                    // See http://www.khronos.org/registry/webgl/specs/latest/1.0/#5.15.2
                    canvas.addEventListener("webglcontextlost", function(e) { alert('WebGL context lost. You will need to reload the page.'); e.preventDefault(); }, false);
                    return canvas;
                })(),
                setStatus: function(text) {
                    if (!Module.setStatus.last) Module.setStatus.last = { time: Date.now(), text: '' };
                    if (text === Module.setStatus.text) return;
                    var m = text.match(/([^(]+)\((\d+(\.\d+)?)\/(\d+)\)/);
                    var now = Date.now();
                    if (m && now - Date.now() < 30) return; // if this is a progress update, skip it if too soon
                    if (m) {
                        text = m[1];
                        progressElement.value = parseInt(m[2])*100;
                        progressElement.max = parseInt(m[4])*100;
                        progressElement.hidden = false;
                        spinnerElement.hidden = false;
                    } else {
                        progressElement.value = null;
                        progressElement.max = null;
                        progressElement.hidden = true;
                        if (!text) spinnerElement.hidden = true;
                    }
                },
                totalDependencies: 0,
                monitorRunDependencies: function(left) {
                    this.totalDependencies = Math.max(this.totalDependencies, left);
                    Module.setStatus(left ? 'Preparing... (' + (this.totalDependencies-left) + '/' + this.totalDependencies + ')' : 'All downloads complete.');
                }
            };
            Module.setStatus('Downloading...');
            window.onerror = function() {
                Module.setStatus('Exception thrown, see JavaScript console');
                spinnerElement.style.display = 'none';
                Module.setStatus = function(text) {
                    if (text) Module.printErr('[post-exception status] ' + text);
                };
            };
            
            var sections = [];
            for (i = 0; i < 23; i++) {
                var section = document.getElementById('section_' + i.toString());
                sections.push(section);
            }
            
            var section_index = 0;
            var section = sections[0];
            
            var showSection = function(other) {
                section.style.display = "none";
                other.style.display = "block";
                section = other;
            };
            
            var next = document.getElementById('next');
            next.addEventListener("click", function() {
                if(section_index < 22) {
                    section_index++;
                }
                showSection(sections[section_index]);
            });
            
            var prev = document.getElementById('prev');
            prev.addEventListener("click", function() {
                if(section_index > 0) {
                    section_index--;
                }
                showSection(sections[section_index]);
            });
            
            var paste_buttons = document.getElementsByClassName("example");
            for (i = 0; i < paste_buttons.length; i++) {
                paste_buttons[i].style.backgroundColor = "red";
            }
        </script>
        <script type='text/javascript'>
            var xhr = new XMLHttpRequest();
            xhr.open('GET', 'tutorial.wasm', true)
            xhr.responseType = 'arraybuffer';
            xhr.onload = function() {
              Module.wasmBinary = xhr.response;
              var script = document.createElement('script');
              script.src = "tutorial.js";
              document.body.appendChild(script);
            };
            xhr.send(null);
        </script>
        <script src="assets/js/prism.js"></script>
    </div>
    </body>
</html>
