<!doctype html>
<html>
    <head>
        <title>Your first game with toy</title>
        <meta charset="utf-8">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<link rel="stylesheet" href="assets/css/alt.css" />
		<link rel="stylesheet" href="assets/css/prism.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
        <style>
            .left-half,
            .right-half {
                position: absolute;
                top: 0px;
                height: 100%;
            }

            .left-half {
                left: 0px;
                width: 33%;
            }
            
            .right-half {
                right: 0px;
                width: 67%;
            }
            
            .emscripten { padding-right: 0; margin-left: auto; margin-right: auto; display: block; }
            .app {
                position: relative;
                top: 0px;
                left: 0px;
                width: 100%;
                height: 100%;
                overflow: hidden;
            }
            div.emscripten { text-align: center; }
            canvas.emscripten { background-color: black; }
            .spinner {
                height: 50px;
                width: 50px;
                margin: 0px auto;
                animation: rotation 0.8s linear infinite;
                border-left: 10px solid rgb(0,150,240);
                border-right: 10px solid rgb(0,150,240);
                border-bottom: 10px solid rgb(0,150,240);
                border-top: 10px solid rgb(100,0,200);
                border-radius: 100%;
                background-color: rgb(200,100,250);
            }
            @keyframes rotation {
                from {transform: rotate(0deg);}
                to {transform: rotate(360deg);}
            }
        </style>
    </head>
    <body>
    <div>
        <div class="left-half">
            <div class="main" style="height: 100%;">
            
                <nav id="nav" style="height: 3.5em; padding: 0.4em">
                    <ul>
                        <li><a href="https://toyengine.io"><img class="image" src="logo/toyengine.png" alt="" style="display: inline; text-align: left;"/></a/</li>
                        <li><a href="https://github.com/hugoam/toy"><span class="icon minor fa-github"></span></a></li>
                        <li><a href="https://twitter.com/hugoamnov"><span class="icon minor fa-twitter"></span></a></li>
                        <li><a href="https://www.patreon.com/toyengine"><img class="image" src="images/patreon_small.png"></a></li>
                    </ul>
                </nav>

                <section id="snippets" class="main special" style="height: calc(100% - 7em); overflow: auto; padding: 1em;">
                    <div class="container" style="height: 100%;">
                        <header class="major">
                            <h2>Live tutorial</h2>
                        </header>

<div id="section_0" class="row gtr-100 gtr-uniform">       
<div class="doc col-12">
    <p>The last week was spent adding the <strong>Wren language</strong> to program toy. Unlike lua, <strong>Wren is class-based</strong>, while sharing many of the advantages that make lua such a great scripting language for games. It's thrilling to finally have this feature because it opens up a world of possibilities for game programming learning material, directly consumable on the web.</p>
    <p>This tutorial will teach you the fundamentals of setting up a <strong>simple yet fully working game</strong> using toy. Thanks to how portable toy is, you will do all this right here, on this web page :)</p>
    <p>You are free to write directly in the script editor, or to use the <code>paste</code> button of each snippet which will insert the code at the current cursor position inside the editor. Using the browser copy function with <code>Ctrl+V</code> will also put it in the editor clipboard, so you can the paste it.</p>
    <p>This tutorial aims to <strong>familiarize yourself with toy user API</strong>, as well as demonstrate the potential for live interactive learning material, and how toy can help achieve that. It uses Wren, but all the functions and classes used here are just a 1:1 mapping of the C++ API. Please keep in mind this is also a proof of concept, which will be further refined and perfected in future iterations.</p>
</div>
</div>

<div id="section_1" class="row gtr-100 gtr-uniform" style="display: none;">       
<div class="doc col-12">
    <p>This tutorial is divided into four successive parts: if you don't want to actually complete it, but just want to see the example code in action, you can preview each part by clicking on the <code>paste</code> button below, and pressing <code>reload</code> in the editor panel.</p>
    <ul>
    <li>part 1 - draw a viewport, control the camera and render randomly colored cubes <button class="button pasterecap" style="color: black !important;">paste code</button></li>
    <li>part 2 - define an entity type, and create a world filled with randomly colored entities <button class="button pasterecap" style="color: black !important;">paste code</button></li>
    <li>part 3 - add physics to our entities, and create a terrain object <button class="button pasterecap" style="color: black !important;">paste code</button></li>
    <li>part 4 - define an agent type whose movement can be controlled, and add a controller to command it <button class="button pasterecap" style="color: black !important;">paste code</button></li>
    </ul>
    <h3>Creating the App</h3>
    <p>The code on the right is your starting point: it setups the minimal toy game, a running app, with a black screen :)
    The <code>GameModule</code> interface provides five main hooks for writing your game logic:</p>
    <ul>
    <li><code>init()</code> is called when initializing the game</li>
    <li><code>start()</code> is called when the game session is started</li>
    <li><code>pump()</code> is called on each frame</li>
    <li><code>scene()</code> is called everytime a scene is created</li>
    <li><code>paint()</code> is called each frame when a scene is painted</li>
    </ul>
</div>
</div>

<div id="section_2" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Creating a viewer</h3>
    <p>The first thing we will do is creating a <code>Viewer</code> in the UI hierarchy of our app. The <code>ui::scene_viewer</code> function declares a special kind of <code>Viewer</code> that contains its own <code>Scene</code>. Call it in the body of the <code>pump()</code> function:</p>
<pre><code class="block language-wren">var viewer = Ui.scene_viewer(ui)
</code><button class="overlay paste">paste</button></pre>
    <p>Note: In Wren, everything is an object, and every function is a method, so this is actually a static method on the <code>Ui</code> class. In C++, it's a regular function.</p>
</div>
<div class="doc col-12">
    <h3>Starting to draw</h3>
    <p>Next, we want to draw some geometry to the viewport. First, we need to initialize the scene graph using <code>Scene::begin()</code>.</p>
<pre><code class="block language-wren">var graph = viewer.scene.begin()
</code><button class="overlay paste">paste</button></pre>
    <p>Press <code>reload</code>. You created an empty black viewport. Just to be sure there is a viewer, you can try this:</p>
<pre><code class="block language-wren">viewer.viewport.clear_colour = Colour.Red
</code><button class="overlay paste">paste</button></pre>
</div>
</div>

<div id="section_3" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Drawing a cube</h3>
    <p>Now that our scene graph is initialized, we can start actually drawing geometry. Add these to the <code>pump()</code> function after creating the viewer:</p>
    <ul>
    <li>declare a node in the graph, which holds the transform, by calling <code>gfx::node()</code>, passing the parent, an object (null), and a position</li>
    <li>declare a shape as a child of this node, by calling<code>gfx::shape()</code> passing the parent, the shape, and a symbol holding the shape colours</li>
    </ul>
<pre><code class="block language-wren">var node = Gfx.node(graph)
Gfx.shape(node, Cube.new(), Symbol.new(Colour.White))
</code><button class="overlay paste">paste</button></pre>
    <p>Press <code>reload</code>. Now you have a white cube in the middle of the viewport.</p>
    <p>You can try passing a different <code>Colour</code>, or a different <code>Cube</code> created with a size argument of type <code>Vec3</code>:</p>
<pre><code class="block language-wren">Colour.new(0.3, 0.8, 0.1)
</code><button class="overlay paste">paste</button></pre>
<pre><code class="block language-wren">Cube.new(Vec3.new(1, 2, 0.5))
</code><button class="overlay paste">paste</button></pre>
</div>
</div>

<div id="section_4" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Controlling the camera</h3>
    <p>The simplest way is to call <code>ui::orbit_controller</code>, which takes a <code>Viewer</code> and controls its camera. It's the simplest controller: it handles input to make the camera orbit around a fixed center point, when pressing <code>Middle Mouse Button</code>.</p>
<pre><code class="block language-wren">var orbit = Ui.orbit_controller(viewer)
</code><button class="overlay paste">paste</button></pre>
</div>
<div class="doc col-12">
    <h3>Drawing more cubes</h3>
    <p>Let's create more cubes, in a loop, by passing different colors and positions to the<code>node()</code> and <code>draw()</code> functions.</p>
<pre><code class="block language-wren">for (i in 0...50) {
    var colour = Colour.hsl(i / 50, 1, 0.5)
    var node = Gfx.node(graph, null, Vec3.new(i * 4 - 100, 0, 0))
    Gfx.draw(node, Cube.new(Vec3.new(1)), Symbol.new(colour))
}
</code><button class="overlay paste">paste</button></pre>
    <p>Note: the <code>Symbol</code> object controls how the shape is rendered. Its two first parameters are the solid/plain colour, and the wireframe colour (if any).</p>
</div>
</div>

<div id="section_5" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Make it random</h3>
    <p>Wren provides a built-in <code>Random</code> number generator, on which you call the <code>float()</code> or <code>int()</code> functions to generate numbers in the given range. First, create it.</p>
<pre><code class="block language-wren">var rand = Random.new()
</code><button class="overlay paste">paste</button></pre>
    <p>Then, inside the loop, let's create random <code>position</code>, <code>extents</code> and <code>colour</code> for each of our cubes.</p>
<pre><code class="block language-wren">var position = Vec3.new(rand.float(-50, 50), rand.float(0, 20), rand.float(-50, 50))
var extents = Vec3.new(rand.float(1, 5))
var colour = Colour.hsl(rand.float(0, 1), 1, 0.5)
</code><button class="overlay paste">paste</button></pre>
    <p>You have to also modify the calls to the <code>node()</code> and <code>draw()</code> functions to use the attributes we created:</p>
<pre><code class="block language-wren">var node = Gfx.node(graph, null, position)
Gfx.draw(node, Cube.new(extents), Symbol.new(colour))
</code><button class="overlay paste">paste</button></pre>
</div>
</div>

<div id="section_6" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>First part recap</h3>
    <p>By now, you should have a code similar to the following:</p>
<pre style="overflow: auto; max-height: 40em;"><code id="recap_0" class="block language-wren">import "random" for Random
import "toy" for ScriptClass, Vec2, Vec3, Complex, Colour, Cube, Sphere, Quad, Symbol, Ui, Gfx, BackgroundMode, DefaultWorld, Entity, Movable, Solid, CollisionShape, GameMode, OrbitMode

foreign class MyGame {
    static new(module) { __constructor.call(MyGame, module) }
    static bind() { __constructor = VirtualConstructor.ref("GameModuleBind") }
    
    init(app, game) { start(app, game) }
    
    start(app, game) {}
    
    pump(app, game, ui) {
        var viewer = Ui.scene_viewer(ui)
        var orbit = Ui.orbit_controller(viewer)
        var graph = viewer.scene.begin()
        
        var rand = Random.new()
        for (i in 0...50) {
            var position = Vec3.new(rand.float(-50, 50), rand.float(0, 20), rand.float(-50, 50))
            var extents = Vec3.new(rand.float(1, 5))
            var colour = Colour.hsl(rand.float(0, 1), 1, 0.5)
                
            var node = Gfx.node(graph, null, position)
            Gfx.draw(node, Cube.new(extents), Symbol.new(colour))
        }
    }
    
    scene(app, scene) {}
    
    paint(app, scene, graph) {}
}

MyGame.bind()

var game = MyGame.new(module)
</code><button class="overlay paste">paste</button></pre>
</div>
</div>

<div id="section_7" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Defining an Entity</h3>
    <p>Until now, we were directly declaring pure graphical shapes. To design a game, it's convenient to define some <code>Entity</code> types.</p>
<pre><code class="block language-wren">class Body {
    construct new(id, parent, position, shape, colour) {
        _complex = Complex.new(id, __cls.type)
        _entity = Entity.new(id, _complex, parent, position)
        _shape = shape
        _colour = colour
        _complex.setup([_entity])
    }
    
    static bind() { __cls = ScriptClass.new("Body", [Entity.type]) }
}
</code><button class="overlay paste">paste</button></pre>
    <p>Let's add the above definition to the top of our script: we define an Entity with only one component: an <code>Entity</code>, which holds the 3d transform, and a list of children. This is enough to formalize the simplest spatial objects.</p>
    <p>We also need to bind this new class, somewhere near the end of the script:</p>
<pre><code class="block language-wren">Body.bind()
</code><button class="overlay paste">paste</button></pre>
</div>
</div>

<div id="section_8" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Accessing fields</h3>
    <p>In Wren, fields cannot be accessed directly, they need to be exposed through getters. We will need to access these three fields to render our entities, so add this code to the <code>Body</code> class:</p>
<pre><code class="block language-wren">entity { _entity }
shape { _shape }
colour { _colour }
</code><button class="overlay paste">paste</button></pre>
</div>
<div class="doc col-12">
    <h3>Setting up our globals</h3>
    <p>Instead of directly declaring pure graphical shapes, we will now render proper Entities. To do this, we need: a <code>World</code> to contain the entities, a <code>Scene</code> to render them, and a list of entities. We will declare them as global variables: add these declarations anywhere in the script, outside of any class:</p>
<pre><code class="block language-wren">var GWorld = null
var GScene = null
var GBodies = []
</code><button class="overlay paste">paste</button></pre>
    <p>Note: in Wren, global variables need to start with an uppercase letter to be accessible from inside class methods.</p>
</div>
</div>

<div id="section_9" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Creating the World</h3>
    <p>We will create all these inside the <code>start()</code> function. First, let's create the game world:</p>
<pre><code class="block language-wren">GWorld = DefaultWorld.new("Example")
game.world = GWorld.world
</code><button class="overlay paste">paste</button></pre>
</div>
<div class="doc col-12">
    <h3>Create the entities</h3>
    <p>We can now create an array of <code>Bodies</code> parented to the <code>World</code> we just created, and use the same random logic we used to draw cubes in the first part of the tutorial, only now we pass the attributes <code>position</code>, <code>shape</code> and <code>colour</code> to the <code>Body</code> constructor:</p>
<pre><code class="block language-wren">var rand = Random.new()
for (i in 0...50) {
    var position = Vec3.new(rand.float(-50, 50), rand.float(0, 20), rand.float(-50, 50))
    var colour = Colour.hsl(rand.float(0, 1), 1, 0.5)
    var shape = Cube.new(Vec3.new(rand.float(1, 5)))
    
    GBodies.add(Body.new(0, GWorld.world.origin, position, shape, colour))
}
</code><button class="overlay paste">paste</button></pre>
</div>
</div>

<div id="section_10" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Creating a Scene</h3>
    <p>Finally we need to add a scene to the game, which we will render in our viewport. Add this to the end of the <code>start()</code> handler:</p>
<pre><code class="block language-wren">GScene = app.add_scene()
</code><button class="overlay paste">paste</button></pre>
    <p>Because the scene is now managed by the application, instead of creating a <code>scene_viewer()</code>, which contains its own <code>Scene</code>, we create a simple <code>viewer()</code> and pass it the scene to render. Let's replace the code inside <code>pump()</code> with this:</p>
<pre><code class="block language-wren">var viewer = Ui.viewer(ui, GScene.scene)
var orbit = Ui.orbit_controller(viewer, 0, -0.37, 100.0)
</code><button class="overlay paste">paste</button></pre>
    <h3>Rendering the Scene</h3>
    <p>The rendering of this scene will now be handled by the application: it will call the <code>paint()</code> handler. Let's add this very simple rendering code inside <code>paint()</code>:</p>
<pre><code class="block language-wren">for (body in GBodies) {
    var self = Gfx.node(graph, body, body.entity.position, body.entity.rotation)
    Gfx.shape(self, body.shape, Symbol.new(body.colour))
}
</code><button class="overlay paste">paste</button></pre>
</div>
</div>

<div id="section_11" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Visual enhancements</h3>
    <p>We can add a radiance environment and a sun light at the beginning of our <code>paint()</code> handler:</p>
<pre><code class="block language-wren">Gfx.radiance(graph, "radiance/tiber_1_1k.hdr", BackgroundMode.Radiance)
Gfx.sun_light(graph, 0, 0.37)
</code><button class="overlay paste">paste</button></pre>
</div>
<div class="doc col-12">
    <h3>Physically based materials</h3>
    <p>We can also render our cubes with a physically based material instead of the default unshaded one. To do this, we call <code>Gfx::pbr_material</code>, which expects the name of the material, and the colour. We will slightly modify the rendering loop and make it like this:</p>
<pre><code class="block language-wren">for (body in GBodies) {
    var node = Gfx.node(graph, body, body.entity.position, body.entity.rotation)
    var material = Gfx.pbr_material(app.gfx, "body %(body.entity.id)", body.colour)
    Gfx.shape(node, body.shape, Symbol.new(Colour.White), 0, material)
}
</code><button class="overlay paste">paste</button></pre>
    <p>We are using Wren's builtin <code>%()</code> operator, which is used to add a formatted value inside of a string literal, to create a material identifier unique to our body.</p>
</div>
</div>

<div id="section_12" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Result</h3>
    <p>Finally, pressing <code>reload</code> should yield the expected scene filled with your randomly created entities of various size, shapes and colours. If you didn't manage, don't worry: the full solution is on the next page.</p>
    <p>This looks very similar to what we did in the first part, right ? Why go to all this trouble for the same result ? In the first part, we only had pure immediately rendered graphical shapes. Having proper game Entities instead, means we can apply all sorts of game logic to these objects, like add physics to them. The next part will show you how to do that.</p>
</div>
</div>

<div id="section_13" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Second part recap</h3>
    <p>By now, you should have a code similar to the following:</p>
<pre style="overflow: auto; max-height: 40em;"><code id="recap_1" class="block language-wren">import "random" for Random
import "toy" for ScriptClass, Vec2, Vec3, Complex, Colour, Cube, Sphere, Quad, Symbol, Ui, Gfx, BackgroundMode, DefaultWorld, Entity, Movable, Solid, CollisionShape, GameMode, OrbitMode

class Body {
    construct new(id, parent, position, shape, colour) {
        _complex = Complex.new(id, __cls.type)
        _entity = Entity.new(id, _complex, parent, position)
        _shape = shape
        _colour = colour
        _complex.setup([_entity])
    }
    
    entity { _entity }
    shape { _shape }
    colour { _colour }
    
    static bind() { __cls = ScriptClass.new("Body", [Entity.type]) }
}

var GWorld = null
var GScene = null
var GBodies = []

foreign class MyGame {
    static new(module) { __constructor.call(MyGame, module) }
    static bind() { __constructor = VirtualConstructor.ref("GameModuleBind") }
    
    init(app, game) { start(app, game) }
    
    start(app, game) {
        GWorld = DefaultWorld.new("Example")
        game.world = GWorld.world
        
        var rand = Random.new()
        for (i in 0...50) {
            var position = Vec3.new(rand.float(-50, 50), rand.float(0, 20), rand.float(-50, 50))
            var colour = Colour.hsl(rand.float(0, 1), 1, 0.5)
            var size = Vec3.new(rand.float(1, 5))
            
            GBodies.add(Body.new(0, GWorld.world.origin, position, Cube.new(size), colour))
        }
        
        GScene = app.add_scene()
    }
    
    pump(app, game, ui) {
        var viewer = Ui.viewer(ui, GScene.scene)
        var orbit = Ui.orbit_controller(viewer, 0, -0.37, 100.0)
    }
    
    scene(app, scene) {}
    
    paint(app, scene, graph) {
        Gfx.radiance(graph, "radiance/tiber_1_1k.hdr", BackgroundMode.Radiance)
        Gfx.sun_light(graph, 0, 0.37)
        
        for (body in GBodies) {
            var node = Gfx.node(graph, body, body.entity.position, body.entity.rotation)
            var material = Gfx.pbr_material(app.gfx, "body %(body.entity.id)", body.colour)
            Gfx.shape(node, body.shape, Symbol.new(Colour.White), 0, material)
        }
    }
}

Body.bind()
MyGame.bind()

var game = MyGame.new(module)
</code><button class="overlay paste">paste</button></pre>
</div>
</div>

<div id="section_14" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Adding physics</h3>
    <p>Let's add one more component to our <code>Body</code> class. The <code>Solid</code> component adds rigid body physics to an <code>Entity</code>. It expects a <code>CollisionShape</code>, which we construct from a <code>Shape</code>, a flag to specify whether it's <code>static</code>, and its <code>mass</code>.</p>
<pre><code class="block language-wren">class Body {
    construct new(id, parent, position, shape, colour) {
        // add these lines
        _movable = Movable.new(_entity)
        _solid = Solid.new(_entity, CollisionShape.new(shape), false, 1.0)
        // ...
        // modify this line: we need to add that new components to the Entity
        _complex.setup([_entity, _movable, _solid])
    }
    
    // ...
    // add a getter for the solid component, we will need it later
    solid { _solid }
    
    // modify this line: we need to register all the components in our Entity class
    static bind() { __cls = ScriptClass.new("Body", [Entity.type, Movable.type, Solid.type]) }
}
</code><button class="overlay paste">paste</button></pre>
    <p>Press <code>reload</code>. Your bodies will now fall downwards!</p>
</div>
</div>

<div id="section_15" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Defining a Terrain class</h3>
    <p>We don't want our objects to fall indefinitely. Let's add a new <code>Terrain</code> Entity class.</p>
<pre><code class="block language-wren">class Terrain {
    construct new(id, parent, size) {
        _quad = Quad.new(Vec3.new(size,0,size), Vec3.new(size,0,-size), Vec3.new(-size,0,-size), Vec3.new(-size,0,size))
        _complex = Complex.new(id, __cls.type)
        _entity = Entity.new(id, _complex, parent, Vec3.new(0, -10, 0))
        _solid = Solid.new(_entity, CollisionShape.new(_quad), true, 0.0)
        _complex.setup([_entity, _solid])
    }
    
    quad { _quad }
    entity { _entity }
    
    static bind() { __cls = ScriptClass.new("Terrain", [Entity.type, Solid.type]) }
}
</code><button class="overlay paste">paste</button></pre>
    <p>Two main differences with our <code>Body</code> class:</p>
    <ul>
    <li>we create a <code>Quad</code> shape, using the <code>size</code> given as a parameter to our constructor</li>
    <li>we pass <code>true</code> to the <code>static</code> parameter of the <code>Solid</code>, and a <code>mass</code> of <code>0.0</code></li>
    <li>we don't need a <code>Movable</code> component this time</li>
    </ul>
</div>
</div>

<div id="section_16" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Bind the Terrain class</h3>
    <p>Like the other classes, we need to bind our <code>Terrain</code> class to register its type.</p>
<pre><code class="block language-wren">Terrain.bind()</code><button class="overlay paste">paste</button></pre>
    <h3>Creating the Terrain object</h3>
    <p>Let's declare a <code>GTerrain</code> global variable next to our other globals, to hold the terrain object.</p>
<pre><code class="block language-wren">var GTerrain = null</code><button class="overlay paste">paste</button></pre>
    <p>Let's create the terrain object, with a <code>size</code> of <code>100</code>, in the body of <code>start()</code> handler:</p>
<pre><code class="block language-wren">GTerrain = Terrain.new(0, GWorld.world.origin, 100)</code><button class="overlay paste">paste</button></pre>
    <p>Press <code>reload</code>. The objects will now fall downwards but be stopped by the invisible <code>Terrain</code> object! We need to render it too.</p>
</div>
</div>

<div id="section_17" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Rendering the Terrain object</h3>
    <p>Finally, we need to add some rendering logic: again, like for the <code>Bodies</code>, we simply render its shape, with a predefined grey pbr material:</p>
<pre><code class="block language-wren">var terrain = Gfx.node(graph, GTerrain, GTerrain.entity.position, GTerrain.entity.rotation)
var material = Gfx.pbr_material(app.gfx, "ground", Colour.new(0.3, 1))
Gfx.shape(terrain, GTerrain.quad, Symbol.new(Colour.White), 0, material)       
</code><button class="overlay paste">paste</button></pre>
    <h3>Alternate cubes and spheres</h3>
    <p>Now that we have physics enabled, it will be more fun with different types of shapes. Let's modify the creation loop slightly, to alternate between <code>Cubes</code> and <code>Spheres</code>:</p>
<pre><code class="block language-wren">for (i in 0...100) {
    var position = Vec3.new(rand.float(-50, 50), rand.float(0, 20), rand.float(-50, 50))
    var colour = Colour.hsl(rand.float(0, 1), 1, 0.5)
    var shape = i % 2 == 0 ? Cube.new(Vec3.new(rand.float(1, 5))) : Sphere.new(rand.float(1, 5))
    GBodies.add(Body.new(0, GWorld.world.origin, position, shape, colour))
}   
</code><button class="overlay paste">paste</button></pre>
</div>
</div>

<div id="section_18" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Third part recap</h3>
    <p>By now, you should have a code similar to the following:</p>
<pre style="overflow: auto; max-height: 40em;"><code id="recap_2" class="block language-wren">import "random" for Random
import "toy" for ScriptClass, Vec2, Vec3, Complex, Colour, Cube, Sphere, Quad, Symbol, Ui, Gfx, BackgroundMode, DefaultWorld, Entity, Movable, Solid, CollisionShape, GameMode, OrbitMode

class Body {
    construct new(id, parent, position, shape, colour) {
        _complex = Complex.new(id, __cls.type)
        _entity = Entity.new(id, _complex, parent, position)
        _movable = Movable.new(_entity)
        _solid = Solid.new(_entity, CollisionShape.new(shape), false, 1.0)
        _shape = shape
        _colour = colour
        _complex.setup([_entity, _movable, _solid])
    }
    
    entity { _entity }
    solid { _solid }
    shape { _shape }
    colour { _colour }
    
    static bind() { __cls = ScriptClass.new("Body", [Entity.type, Movable.type, Solid.type]) }
}

class Terrain {
    construct new(id, parent, size) {
        _quad = Quad.new(Vec3.new(size,0,size), Vec3.new(size,0,-size), Vec3.new(-size,0,-size), Vec3.new(-size,0,size))
        _complex = Complex.new(id, __cls.type)
        _entity = Entity.new(id, _complex, parent, Vec3.new(0, -10, 0))
        _solid = Solid.new(_entity, CollisionShape.new(_quad), true, 0.0)
        _complex.setup([_entity, _solid])
    }
    
    quad { _quad }
    entity { _entity }
    
    static bind() { __cls = ScriptClass.new("Terrain", [Entity.type, Solid.type]) }
}

var GWorld = null
var GScene = null
var GTerrain = null
var GBodies = []

foreign class MyGame {
    static new(module) { __constructor.call(MyGame, module) }
    static bind() { __constructor = VirtualConstructor.ref("GameModuleBind") }
    
    init(app, game) { start(app, game) }
    
    start(app, game) {
        GWorld = DefaultWorld.new("World")
        game.world = GWorld.world
        
        GTerrain = Terrain.new(0, GWorld.world.origin, 100)
        
        var rand = Random.new()
        for (i in 0...100) {
            var position = Vec3.new(rand.float(-50, 50), rand.float(0, 20), rand.float(-50, 50))
            var colour = Colour.hsl(rand.float(0, 1), 1, 0.5)
            var shape = i % 2 == 0 ? Cube.new(Vec3.new(rand.float(1, 5))) : Sphere.new(rand.float(1, 5))
            GBodies.add(Body.new(0, GWorld.world.origin, position, shape, colour))
        }
        
        GScene = app.add_scene()
    }
    
    pump(app, game, ui) {
        var viewer = Ui.viewer(ui, GScene.scene)
        var orbit = Ui.orbit_controller(viewer, 0, -0.37, 100.0)
    }
    
    scene(app, scene) {}
    
    paint(app, scene, graph) {
        Gfx.radiance(graph, "radiance/tiber_1_1k.hdr", BackgroundMode.Radiance)
        Gfx.sun_light(graph, 0, 0.37)
        
        var terrain = Gfx.node(graph, GTerrain, GTerrain.entity.position, GTerrain.entity.rotation)
        var material = Gfx.pbr_material(app.gfx, "ground", Colour.new(0.3, 1))
        Gfx.shape(terrain, GTerrain.quad, Symbol.new(Colour.White), 0, material)
        
        for (body in GBodies) {
            var node = Gfx.node(graph, body, body.entity.position, body.entity.rotation)
            var material = Gfx.pbr_material(app.gfx, "body %(body.entity.id)", body.colour)
            Gfx.shape(node, body.shape, Symbol.new(Colour.White), 0, material)
        }
    }
}

Body.bind()
Terrain.bind()
MyGame.bind()

var game = MyGame.new(module)
</code><button class="overlay paste">paste</button></pre>
</div>
</div>

<div id="section_19" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Defining an Agent class</h3>
    <p>To allow the user to control an object, let's add one more class: an <code>Agent</code>, which is a special kind of <code>Body</code>, with additional logic so that its movement can be controlled.</p>
<pre><code class="block language-wren">class Agent is Body {
    construct new(id, parent, position, shape, colour) {
        super(id, parent, position, shape, colour)
        _aiming = true
        _angles = Vec2.new(0)
        _force = Vec3.new(0)
        _torque = Vec3.new(0)
    }
    
    aiming { _aiming }
    angles { _angles }
    force { _force }
    torque { _torque }
}
</code><button class="overlay paste">paste</button></pre>
    <p>The <code>force</code> and <code>torque</code> will represent the translation and rotation forces applied to our agent, relative to itself. The <code>aiming</code> and <code>angles</code> fields will be used by the camera controller, to determine in which direction we are looking.</p>
</div>
</div>

<div id="section_20" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Adding the movement logic</h3>
    <p>Each frame, we will use the previously defined fields to modify the velocity of the actual simulated physics object. Let's add an <code>update()</code> function that we will call each frame to do the following:</p>
    <ul>
    <li>calculate the <code>force</code> in absolute coordinates</li>
    <li>apply the absolute <code>force</code>, together with the <code>torque</code>, to the physical <code>Solid</code> object</li>
    <li>set the <code>angular factor</code> to <code>0</code> to maintain our object upright in all situations</li>
    </ul>
<pre><code class="block language-wren">class Agent is Body {
    // ...
    update() {
        var velocity = this.solid.impl.linear_velocity()
        var force = Mud.rotate(this.entity.rotation, _force)
        this.solid.impl.set_linear_velocity(Vec3.new(force.x, velocity.y - 1, force.z))
        this.solid.impl.set_angular_velocity(_torque)
        this.solid.impl.set_angular_factor(Vec3.new(0))
    }
}
</code><button class="overlay paste">paste</button></pre>
    <p>Note: We are combining the force with the vertical component of the velocity, minus one, to simulate gravity.</p>
</div>
</div>

<div id="section_21" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Create the player Agent</h3>
    <p>Create another global variable <code>GAgent</code> near the other ones to hold our player agent.</p>
<pre><code class="block language-wren">GAgent = null
</code><button class="overlay paste">paste</button></pre>
    <p>Then add this code to create it, in the body of the <code>start()</code> handler:</p>
<pre><code class="block language-wren">GAgent = Agent.new(0, GWorld.world.origin, Vec3.new(0), Cube.new(), Colour.White)
</code><button class="overlay paste">paste</button></pre>
    <p>By just appending it to our list of bodies, we ensure it will be rendered with the other bodies:</p>
<pre><code class="block language-wren">GBodies.add(GAgent)
</code><button class="overlay paste">paste</button></pre>
</div>
</div>


<div id="section_22" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Handling the input/control logic</h3>
    <p>To correctly handle input to control our object, we have to add three things inside the <code>pump()</code> handler right after creating the viewer:</p>
    <ul>
    <li>call <code>hybrid_controller</code> with <code>ThirdPerson</code> mode: it handles the mouse <code>Agent</code> aiming angle for us</li>
    <li>call <code>velocity_controller</code>, to map the arrow keys to update the <code>force</code> and <code>torque</code> accordingly</li>
    </ul>
<pre><code class="block language-wren">Ui.hybrid_controller(viewer, OrbitMode.ThirdPerson, GAgent.entity, GAgent.aiming, GAgent.angles)
Ui.velocity_controller(viewer, GAgent.force, GAgent.torque, 20)
</code><button class="overlay paste">paste</button></pre>
    <p>Finally we need to call the <code>update()</code> function we implemented on our <code>Agent</code> class, to apply the forces to the physical object.</p>
<pre><code class="block language-wren">GAgent.update()</code><button class="overlay paste">paste</button></pre>
</div>
</div>

<div id="section_23" class="row gtr-50 gtr-uniform" style="display: none;">
<div class="doc col-12">
    <h3>Fourth part recap</h3>
    <p>By now, you should have a code similar to the following:</p>
<pre style="overflow: auto; max-height: 40em;"><code id="recap_3" class="block language-wren">import "random" for Random
import "toy" for ScriptClass, Complex, Vec2, Vec3, Colour, Cube, Sphere, Quad, Symbol, Ui, Gfx, BackgroundMode, DefaultWorld, Entity, Movable, Solid, CollisionShape, GameMode, OrbitMode

class Body {
    construct new(id, parent, position, shape, colour) {
        _complex = Complex.new(id, __cls.type)
        _entity = Entity.new(id, _complex, parent, position)
        _movable = Movable.new(_entity)
        _solid = Solid.new(_entity, CollisionShape.new(shape), false, 1.0)
        _shape = shape
        _colour = colour
        _complex.setup([_entity, _movable, _solid])
    }
    
    entity { _entity }
    solid { _solid }
    shape { _shape }
    colour { _colour }
    
    static bind() { __cls = ScriptClass.new("Body", [Entity.type, Movable.type, Solid.type]) }
}

class Agent is Body {
    construct new(id, parent, position, shape, colour) {
        super(id, parent, position, shape, colour)
        _aiming = true
        _angles = Vec2.new(0)
        _force = Vec3.new(0)
        _torque = Vec3.new(0)
    }
    
    update() {
        var velocity = this.solid.impl.linear_velocity()
        var force = Mud.rotate(this.entity.rotation, _force)
        this.solid.impl.set_linear_velocity(Vec3.new(force.x, velocity.y - 1, force.z))
        this.solid.impl.set_angular_velocity(_torque)
        this.solid.impl.set_angular_factor(Vec3.new(0))
    }
    
    aiming { _aiming }
    angles { _angles }
    force { _force }
    torque { _torque }
}

class Terrain {
    construct new(id, parent, size) {
        _quad = Quad.new(Vec3.new(size,0,size), Vec3.new(size,0,-size), Vec3.new(-size,0,-size), Vec3.new(-size,0,size))
        _complex = Complex.new(id, __cls.type)
        _entity = Entity.new(id, _complex, parent, Vec3.new(0, -10, 0))
        _solid = Solid.new(_entity, CollisionShape.new(_quad), true, 0.0)
        _complex.setup([_entity, _solid])
    }
    
    quad { _quad }
    entity { _entity }
    
    static bind() { __cls = ScriptClass.new("Terrain", [Entity.type, Solid.type]) }
}

var GWorld = null
var GScene = null
var GTerrain = null
var GBodies = []
var GAgent = null

foreign class MyGame {
    static new(module) { __constructor.call(MyGame, module) }
    static bind() { __constructor = VirtualConstructor.ref("GameModuleBind") }
    
    init(app, game) { start(app, game) }
    
    start(app, game) {
        GWorld = DefaultWorld.new("World")
        game.world = GWorld.world
        
        GTerrain = Terrain.new(0, GWorld.world.origin, 100)
        GAgent = Agent.new(0, GWorld.world.origin, Vec3.new(0), Cube.new(), Colour.White)
        GBodies.add(GAgent)
        
        var rand = Random.new()
        for (i in 0...100) {
            var position = Vec3.new(rand.float(-50, 50), rand.float(0, 20), rand.float(-50, 50))
            var colour = Colour.hsl(rand.float(0, 1), 1, 0.5)
            var shape = i % 2 == 0 ? Cube.new(Vec3.new(rand.float(1, 5))) : Sphere.new(rand.float(1, 5))
            GBodies.add(Body.new(0, GWorld.world.origin, position, shape, colour))
        }
        
        GScene = app.add_scene()
    }
    
    pump(app, game, ui) {
        var viewer = Ui.viewer(ui, GScene.scene)

        Ui.hybrid_controller(viewer, OrbitMode.ThirdPerson, GAgent.entity, GAgent.aiming, GAgent.angles)
        Ui.velocity_controller(viewer, GAgent.force, GAgent.torque, 20)

        GAgent.update()
    }
    
    scene(app, scene) {}
    
    paint(app, scene, graph) {
        Gfx.radiance(graph, "radiance/tiber_1_1k.hdr", BackgroundMode.Radiance)
        Gfx.sun_light(graph, 0, 0.37)
        
        var terrain = Gfx.node(graph, GTerrain, GTerrain.entity.position, GTerrain.entity.rotation)
        var material = Gfx.pbr_material(app.gfx, "ground", Colour.new(0.3, 1))
        Gfx.shape(terrain, GTerrain.quad, Symbol.new(Colour.White), 0, material)
        
        for (body in GBodies) {
            var node = Gfx.node(graph, body, body.entity.position, body.entity.rotation)
            var material = Gfx.pbr_material(app.gfx, "body %(body.entity.id)", body.colour)
            Gfx.shape(node, body.shape, Symbol.new(Colour.White), 0, material)
        }
    }
}

Body.bind()
Terrain.bind()
MyGame.bind()

var game = MyGame.new(module)
</code><button class="overlay paste">paste</button></pre>
</div>
</div>

                    </div>
                </section>
                
                <ul style="height: 3.5em; padding: 0.5em 5em 0.5em 5em; background-color: rgba(60, 60, 60, 1);">
                    <li style="display: inline-block;"><a id="prev" class="button">Previous</a></li>
                    <li style="display: inline-block;"><a id="next" class="button">Next</a></li>
                </ul>
            </div>
        </div>
        <div class="right-half">
            <canvas class="emscripten app" id="canvas" tabindex="0" oncontextmenu="event.preventDefault()"></canvas>
            <figure style="overflow:visible;" id="spinner"><div class="spinner"></div></figure>
            <div class="emscripten">
                <progress value="0" max="100" id="progress" hidden=1></progress>    
            </div>
        </div>
        <script type='text/javascript'>
            var canvas = document.getElementById('canvas');
            var progress = document.getElementById('progress');
            var spinner = document.getElementById('spinner');
            var Module = {
                preRun: [function() {
                
                    var copy = Module.cwrap('copy', null, ['string']);
                    var paste = Module.cwrap('paste', null, ['string']);
                    
                    function handleCopy (e) {
                        var clipboardData = e.clipboardData || window.clipboardData;
                        var text = window.getSelection().toString();
                        copy(text);
                        canvas.focus();
                    }

                    //document.addEventListener('paste', handleCopy);
                    document.addEventListener('copy', handleCopy);
                    
                    var paste_buttons = document.getElementsByClassName("paste");
                    for (i = 0; i < paste_buttons.length; i++) {
                        paste_buttons[i].addEventListener('click', function() {
                            var text = this.previousSibling.innerText
                            Module.ccall('paste', null, ['string'], [text]);
                            canvas.focus();
                        });
                    }
                    
                    var paste_recap_buttons = document.getElementsByClassName("pasterecap");
                    for (i = 0; i < paste_recap_buttons.length; i++) {
                        paste_recap_buttons[i].recap_index = i;
                        paste_recap_buttons[i].addEventListener('click', function() {
                            var recap = document.getElementById('recap_' + this.recap_index.toString());
                            var text = recap.innerText;
                            Module.ccall('paste', null, ['string'], [text]);
                            canvas.focus();
                        });
                    }
                }],
                postRun: [],
                print: (function() {
                    return function(text) {
                        if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ');
                        console.log(text);
                    };
                })(),
                printErr: function(text) {
                    if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ');
                    if (0) { // XXX disabled for safety typeof dump == 'function') {
                        dump(text + '\n'); // fast, straight to the real console
                    } else {
                        console.error(text);
                    }
                },
                canvas: (function() {
                    var canvas = document.getElementById('canvas');
                    // As a default initial behavior, pop up an alert when webgl context is lost. To make your
                    // application robust, you may want to override this behavior before shipping!
                    // See http://www.khronos.org/registry/webgl/specs/latest/1.0/#5.15.2
                    canvas.addEventListener("webglcontextlost", function(e) { alert('WebGL context lost. You will need to reload the page.'); e.preventDefault(); }, false);
                    canvas.focus();
                    return canvas;
                })(),
                setStatus: function(text) {
                    if (!Module.setStatus.last) Module.setStatus.last = { time: Date.now(), text: '' };
                    if (text === Module.setStatus.text) return;
                    var m = text.match(/([^(]+)\((\d+(\.\d+)?)\/(\d+)\)/);
                    var now = Date.now();
                    if (m && now - Date.now() < 30) return; // if this is a progress update, skip it if too soon
                    if (m) {
                        text = m[1];
                        progress.value = parseInt(m[2])*100;
                        progress.max = parseInt(m[4])*100;
                        progress.style.display = 'block';
                        spinner.style.display = 'block';
                    } else {
                        progress.value = null;
                        progress.max = null;
                        progress.style.display = 'none';
                        if (!text) spinner.style.display = 'none';
                    }
                },
                totalDependencies: 0,
                monitorRunDependencies: function(left) {
                    this.totalDependencies = Math.max(this.totalDependencies, left);
                    Module.setStatus(left ? 'Preparing... (' + (this.totalDependencies-left) + '/' + this.totalDependencies + ')' : 'All downloads complete.');
                }
            };
            Module.setStatus('Downloading...');
            window.onerror = function() {
                Module.setStatus('Exception thrown, see JavaScript console');
                spinner.style.display = 'none';
                Module.setStatus = function(text) {
                    if (text) Module.printErr('[post-exception status] ' + text);
                };
            };
            
            canvas.focus();
            
            var sections = [];
            for (i = 0; i < 24; i++) {
                var section = document.getElementById('section_' + i.toString());
                sections.push(section);
            }
            
            var section_index = 0;
            var section = sections[0];
            
            var showSection = function(other) {
                section.style.display = "none";
                other.style.display = "block";
                section = other;
            };
            
            var next = document.getElementById('next');
            next.addEventListener("click", function() {
                if(section_index < 23) {
                    section_index++;
                }
                showSection(sections[section_index]);
                canvas.focus();
            });
            
            var prev = document.getElementById('prev');
            prev.addEventListener("click", function() {
                if(section_index > 0) {
                    section_index--;
                }
                showSection(sections[section_index]);
                canvas.focus();
            });
            
        </script>
        <script type='text/javascript'>
            var xhr = new XMLHttpRequest();
            xhr.open('GET', 'tutorial.wasm', true)
            xhr.responseType = 'arraybuffer';
            xhr.onload = function() {
              Module.wasmBinary = xhr.response;
              var script = document.createElement('script');
              script.src = "tutorial.js";
              document.body.appendChild(script);
            };
            xhr.send(null);
        </script>
        <script src="assets/js/prism.js"></script>
    </div>
    </body>
</html>
